---

description: Python best practices and patterns for modern software development with VideoMilker CLI application
globs: **/*.py,src**/*.py,tests/**/*.py
alwaysApply: false
---

# Python Best Practices

## Project Structure

- Use src-layout with `src/your_package_name/`
- Place tests in `tests/` directory parallel to `src/`
- Keep configuration in `config/` or as environment variables
- Store requirements in `requirements.txt` or `pyproject.toml`
- Place static files in `assets/` directory (not `static/`)
- Use `data/` directory for application data (downloads, logs, temp files)

## Code Style

- Follow Black code formatting
- Use isort for import sorting
- Follow PEP 8 naming conventions:
  - snake_case for functions and variables
  - PascalCase for classes
  - UPPER_CASE for constants
- Maximum line length of 88 characters (Black default)
- Use relative imports for internal package modules (e.g., `from ..config.settings import Settings`)

## Type Hints

- Use type hints for all function parameters and returns
- Import types from `typing` module
- Use `Optional[Type]` instead of `Type | None` (Python 3.8+ compatibility)
- Use `TypeVar` for generic types
- Define custom types in `types.py` or within the module
- Use `Protocol` for duck typing

## Error Handling

- Create custom exception classes in `exceptions/` directory
- Use proper try-except blocks
- Implement proper logging
- Return proper error responses
- Handle edge cases properly
- Use proper error messages
- Map external library errors to custom exceptions

## Documentation

- Use Google-style docstrings
- Keep README.md updated
- Use proper inline comments
- Document environment setup
- Include project architecture documentation in `docs/`

## Development Workflow

- Use virtual environments (.venv)
- Use proper Git workflow
- Implement proper logging
- Use pytest for testing
- Use coverage reporting

## Dependencies

- Use a pyproject.toml file for building and metadata
- Pin dependency versions with >= for minimum versions
- Use requirements.txt for production dependencies
- Separate dev dependencies in pyproject.toml optional-dependencies
- Use proper package versions
- Regularly update dependencies
- Include both setup.py and pyproject.toml for compatibility

## Application-Specific Patterns

- Use Rich library for terminal UI components
- Implement async/await patterns for I/O operations
- Use Pydantic for configuration and data validation
- Structure CLI applications with Click or Typer
- Use pathlib for file operations
- Implement proper progress tracking for long-running operations
